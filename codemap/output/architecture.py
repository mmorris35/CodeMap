"""Architecture documentation generator."""

from __future__ import annotations

from datetime import datetime, timezone
from typing import TYPE_CHECKING, Any

from codemap.logging_config import get_logger
from codemap.output.mermaid import MermaidGenerator

if TYPE_CHECKING:
    from codemap.analyzer.graph import DependencyGraph
    from codemap.output.schemas import CodeMapSchema

logger = get_logger(__name__)


class ArchitectureGenerator:
    """Generates ARCHITECTURE.md documentation from code analysis."""

    def __init__(self) -> None:
        """Initialize architecture generator."""
        self._mermaid = MermaidGenerator()

    def generate(
        self,
        graph: DependencyGraph,
        code_map: CodeMapSchema,
        project_name: str = "Project",
    ) -> str:
        """Generate ARCHITECTURE.md content with inline mermaid diagrams.

        Args:
            graph: Dependency graph for visualization.
            code_map: CODE_MAP data with symbols and dependencies.
            project_name: Name of the project for the header.

        Returns:
            Markdown content for ARCHITECTURE.md.
        """
        logger.info("Generating ARCHITECTURE.md")

        lines: list[str] = []

        # Header
        lines.append(f"# {project_name} Architecture")
        lines.append("")
        lines.append(
            f"*Generated by [CodeMap](https://github.com/mmorris35/CodeMap) "
            f"on {datetime.now(timezone.utc).strftime('%Y-%m-%d %H:%M UTC')}*"
        )
        lines.append("")

        # Summary section
        lines.extend(self._generate_summary(code_map))

        # Module diagram
        lines.extend(self._generate_diagram_section(graph))

        # Module table
        lines.extend(self._generate_module_table(code_map))

        # Hotspots section
        lines.extend(self._generate_hotspots(code_map))

        # Dependencies section
        lines.extend(self._generate_dependencies_section(code_map))

        return "\n".join(lines)

    def _generate_summary(self, code_map: CodeMapSchema) -> list[str]:
        """Generate project summary section."""
        lines: list[str] = []
        lines.append("## Summary")
        lines.append("")

        symbols = code_map.get("symbols", [])
        dependencies = code_map.get("dependencies", [])

        # Count by kind
        kinds: dict[str, int] = {}
        for sym in symbols:
            kind = sym.get("kind", "unknown")
            kinds[kind] = kinds.get(kind, 0) + 1

        # Count unique modules
        modules: set[str] = set()
        for sym in symbols:
            file_path = sym.get("file", "")
            if file_path:
                # Extract module name from file path
                module = file_path.replace(".py", "").replace("/", ".")
                # Get top-level module
                top_module = module.split(".")[0]
                modules.add(top_module)

        lines.append(f"- **Modules**: {len(modules)}")
        lines.append(f"- **Total Symbols**: {len(symbols)}")

        for kind in ["class", "function", "method"]:
            if kind in kinds:
                lines.append(f"  - {kind.title()}es: {kinds[kind]}")

        lines.append(f"- **Dependencies**: {len(dependencies)}")
        lines.append("")

        return lines

    def _generate_diagram_section(self, graph: DependencyGraph) -> list[str]:
        """Generate module diagram section with inline mermaid."""
        lines: list[str] = []
        lines.append("## Module Dependency Graph")
        lines.append("")
        lines.append("```mermaid")

        diagram = self._mermaid.generate_module_diagram(graph)
        lines.append(diagram)

        lines.append("```")
        lines.append("")

        return lines

    def _generate_module_table(self, code_map: CodeMapSchema) -> list[str]:
        """Generate module details table."""
        lines: list[str] = []
        lines.append("## Modules")
        lines.append("")

        symbols = code_map.get("symbols", [])
        dependencies = code_map.get("dependencies", [])

        # Count symbols per module (by file)
        module_symbols: dict[str, int] = {}
        module_files: dict[str, set[str]] = {}

        for sym in symbols:
            file_path = sym.get("file", "unknown")
            # Extract module from file path
            if "/" in file_path:
                module = file_path.replace(".py", "").split("/")[0]
            else:
                module = file_path.replace(".py", "")

            module_symbols[module] = module_symbols.get(module, 0) + 1
            if module not in module_files:
                module_files[module] = set()
            module_files[module].add(file_path)

        # Count dependencies per module
        module_deps: dict[str, int] = {}
        module_dependents: dict[str, int] = {}

        for dep in dependencies:
            from_sym = dep.get("from_sym", "")
            to_sym = dep.get("to_sym", "")

            from_module = from_sym.split(".")[0] if from_sym else ""
            to_module = to_sym.split(".")[0] if to_sym else ""

            if from_module:
                module_deps[from_module] = module_deps.get(from_module, 0) + 1
            if to_module:
                module_dependents[to_module] = module_dependents.get(to_module, 0) + 1

        if not module_symbols:
            lines.append("*No modules found.*")
            lines.append("")
            return lines

        lines.append("| Module | Files | Symbols | Dependencies | Dependents |")
        lines.append("|--------|-------|---------|--------------|------------|")

        for module in sorted(module_symbols.keys()):
            files = len(module_files.get(module, set()))
            syms = module_symbols.get(module, 0)
            deps = module_deps.get(module, 0)
            dependents = module_dependents.get(module, 0)
            lines.append(f"| `{module}` | {files} | {syms} | {deps} | {dependents} |")

        lines.append("")

        return lines

    def _generate_hotspots(self, code_map: CodeMapSchema) -> list[str]:
        """Generate hotspots section - modules with high coupling."""
        lines: list[str] = []
        lines.append("## Hotspots")
        lines.append("")
        lines.append(
            "Hotspots are symbols with many dependents. Changes to these require careful review."
        )
        lines.append("")

        dependencies = code_map.get("dependencies", [])

        # Count dependents per symbol
        dependent_count: dict[str, int] = {}
        for dep in dependencies:
            to_sym = dep.get("to_sym", "")
            if to_sym:
                dependent_count[to_sym] = dependent_count.get(to_sym, 0) + 1

        # Find hotspots (symbols with 3+ dependents)
        hotspots = [(sym, count) for sym, count in dependent_count.items() if count >= 3]
        hotspots.sort(key=lambda x: x[1], reverse=True)

        if not hotspots:
            lines.append("*No hotspots detected (no symbols with 3+ dependents).*")
            lines.append("")
            return lines

        lines.append("| Symbol | Dependents | Risk |")
        lines.append("|--------|------------|------|")

        for sym, count in hotspots[:10]:  # Top 10
            risk = "HIGH" if count >= 5 else "MEDIUM"
            lines.append(f"| `{sym}` | {count} | {risk} |")

        lines.append("")

        return lines

    def _generate_dependencies_section(self, code_map: CodeMapSchema) -> list[str]:
        """Generate key dependencies section."""
        lines: list[str] = []
        lines.append("## Key Dependencies")
        lines.append("")

        dependencies = code_map.get("dependencies", [])

        if not dependencies:
            lines.append("*No dependencies found.*")
            lines.append("")
            return lines

        # Group by kind
        by_kind: dict[str, list[Any]] = {}
        for dep in dependencies:
            kind = dep.get("kind", "unknown")
            if kind not in by_kind:
                by_kind[kind] = []
            by_kind[kind].append(dep)

        for kind in sorted(by_kind.keys()):
            deps = by_kind[kind]
            lines.append(f"### {kind.title()} ({len(deps)})")
            lines.append("")

            # Show first 10
            for dep in deps[:10]:
                from_sym = dep.get("from_sym", "?")
                to_sym = dep.get("to_sym", "?")
                lines.append(f"- `{from_sym}` â†’ `{to_sym}`")

            if len(deps) > 10:
                lines.append(f"- *...and {len(deps) - 10} more*")

            lines.append("")

        return lines
