/**
 * Cloudflare KV storage abstraction for CodeMap MCP Server
 * Provides user-scoped data access with validation and TTL support
 */

import { z } from 'zod';

/**
 * Symbol schema - represents a single code symbol (function, class, etc.)
 */
const SymbolSchema = z.object({
  qualified_name: z.string().describe('Fully qualified symbol name'),
  kind: z.enum(['module', 'class', 'function', 'method']).describe('Type of symbol'),
  file: z.string().describe('Path to file containing symbol'),
  line: z.number().int().positive().describe('Line number of symbol definition'),
  column: z.number().int().nonnegative().optional().describe('Column number of symbol definition'),
  docstring: z.string().nullable().optional().describe('Docstring for the symbol'),
  signature: z.string().optional().describe('Function/method signature'),
  task_links: z.array(z.string()).optional().describe('Task IDs this symbol implements'),
});

export type Symbol = z.infer<typeof SymbolSchema>;

/**
 * Dependency schema - represents a dependency between two symbols
 */
const DependencySchema = z.object({
  from_sym: z.string().describe('Source symbol qualified name'),
  to_sym: z.string().describe('Target symbol qualified name'),
  kind: z.enum(['calls', 'imports', 'inherits']).optional().describe('Type of dependency'),
  locations: z
    .array(
      z.object({
        file: z.string(),
        line: z.number().int().positive(),
      })
    )
    .optional()
    .describe('Where this dependency occurs in source'),
});

export type Dependency = z.infer<typeof DependencySchema>;

/**
 * CodeMap schema - the complete code map structure
 * Matches the CODE_MAP.json format generated by codemap analyzer
 */
export const CodeMapSchema = z.object({
  version: z.string().regex(/^\d+\.\d+$/).describe('Schema version'),
  generated_at: z.string().datetime().describe('ISO 8601 timestamp of generation'),
  source_root: z.string().describe('Root directory of analyzed source code'),
  symbols: z.array(SymbolSchema).describe('All symbols found in the codebase'),
  dependencies: z.array(DependencySchema).describe('All detected dependencies between symbols'),
  schema: z.string().optional().describe('URL of the JSON schema'),
});

export type CodeMap = z.infer<typeof CodeMapSchema>;


/**
 * CodeMapStorage class - user-scoped KV storage wrapper
 *
 * All operations are scoped to a specific user to prevent data leakage.
 * Keys use the format: `user:{userId}:project:{projectId}` for projects
 * and `user:{userId}:cache:{cacheKey}` for cached queries.
 *
 * This ensures that users can only access their own data even if they
 * somehow access the KV namespace directly.
 */
export class CodeMapStorage {
  /**
   * Default TTL for cached query results (1 hour)
   */
  private readonly defaultCacheTTL = 3600;

  /**
   * Initialize storage with a KV namespace
   *
   * @param kv - Cloudflare KV namespace instance
   */
  constructor(private kv: KVNamespace) {}

  /**
   * Generate a user-scoped project key
   *
   * All keys are prefixed with user ID to prevent cross-tenant access.
   * Format: `user:{userId}:project:{projectId}`
   *
   * @param userId - Unique user identifier (derived from API key hash)
   * @param projectId - Project identifier
   * @returns Formatted user-scoped key
   */
  private projectKey(userId: string, projectId: string): string {
    return `user:${userId}:project:${projectId}`;
  }

  /**
   * Generate a user-scoped cache key
   *
   * Format: `user:{userId}:cache:{cacheKey}`
   *
   * @param userId - Unique user identifier
   * @param cacheKey - Cache key (typically hash of query)
   * @returns Formatted user-scoped cache key
   */
  private cacheKey(userId: string, cacheKey: string): string {
    return `user:${userId}:cache:${cacheKey}`;
  }

  /**
   * Save a CodeMap to KV storage
   *
   * Validates the CodeMap against the schema before saving.
   * Saves to user-scoped key: `user:{userId}:project:{projectId}`
   *
   * @param userId - User ID (from API key)
   * @param projectId - Project identifier
   * @param codeMap - CodeMap object to save
   * @throws {z.ZodError} If CodeMap fails validation
   *
   * @example
   * ```typescript
   * await storage.saveCodeMap('user123', 'my-app', codeMapData);
   * ```
   */
  async saveCodeMap(userId: string, projectId: string, codeMap: unknown): Promise<void> {
    const validated = CodeMapSchema.parse(codeMap);
    const json = JSON.stringify(validated);
    await this.kv.put(this.projectKey(userId, projectId), json);
  }

  /**
   * Retrieve a CodeMap from KV storage
   *
   * Returns null if the project does not exist.
   * Validates data against schema before returning.
   *
   * @param userId - User ID (from API key)
   * @param projectId - Project identifier
   * @returns Parsed and validated CodeMap, or null if not found
   * @throws {z.ZodError} If stored data fails validation (data corruption)
   *
   * @example
   * ```typescript
   * const codeMap = await storage.getCodeMap('user123', 'my-app');
   * if (codeMap) {
   *   console.log(`Found ${codeMap.symbols.length} symbols`);
   * }
   * ```
   */
  async getCodeMap(userId: string, projectId: string): Promise<CodeMap | null> {
    const raw = await this.kv.get(this.projectKey(userId, projectId));
    if (!raw) return null;
    return CodeMapSchema.parse(JSON.parse(raw));
  }

  /**
   * Delete a CodeMap from KV storage
   *
   * Safe to call even if the project doesn't exist.
   * Also deletes any cached query results for this project.
   *
   * @param userId - User ID (from API key)
   * @param projectId - Project identifier
   *
   * @example
   * ```typescript
   * await storage.deleteCodeMap('user123', 'my-app');
   * ```
   */
  async deleteCodeMap(userId: string, projectId: string): Promise<void> {
    await this.kv.delete(this.projectKey(userId, projectId));
    // Note: Cache cleanup could be implemented here if needed
  }

  /**
   * List all project IDs for a specific user
   *
   * Returns only projects belonging to the authenticated user.
   * Uses user-scoped prefix to prevent listing other users' projects.
   *
   * @param userId - User ID (from API key)
   * @returns Array of project IDs owned by this user
   *
   * @example
   * ```typescript
   * const projects = await storage.listProjects('user123');
   * console.log(`User has ${projects.length} projects`);
   * ```
   */
  async listProjects(userId: string): Promise<string[]> {
    const prefix = this.projectKey(userId, '');
    const result = await this.kv.list({ prefix });
    return result.keys.map((key: { name: string }) => key.name.replace(prefix, ''));
  }

  /**
   * Save cached query results with TTL
   *
   * Useful for caching expensive analysis operations.
   * Results automatically expire after specified TTL (default 1 hour).
   *
   * @param userId - User ID (from API key)
   * @param cacheKey - Cache key (typically hash of query parameters)
   * @param data - Data to cache
   * @param ttlSeconds - Time to live in seconds (default: 1 hour)
   *
   * @example
   * ```typescript
   * const queryHash = sha256('get_dependents_my-app_auth.validate');
   * await storage.saveCache('user123', queryHash, result, 3600);
   * ```
   */
  async saveCache(userId: string, cacheKey: string, data: unknown, ttlSeconds?: number): Promise<void> {
    const json = JSON.stringify(data);
    const ttl = ttlSeconds ?? this.defaultCacheTTL;
    await this.kv.put(this.cacheKey(userId, cacheKey), json, {
      expirationTtl: ttl,
    });
  }

  /**
   * Retrieve cached query results
   *
   * @param userId - User ID (from API key)
   * @param cacheKey - Cache key to look up
   * @returns Cached data, or null if not found or expired
   *
   * @example
   * ```typescript
   * const cached = await storage.getCache('user123', queryHash);
   * if (cached) {
   *   return cached; // Use cached result
   * }
   * ```
   */
  async getCache<T = unknown>(userId: string, cacheKey: string): Promise<T | null> {
    const raw = await this.kv.get(this.cacheKey(userId, cacheKey));
    if (!raw) return null;
    return JSON.parse(raw) as T;
  }

  /**
   * Delete cached query results
   *
   * @param userId - User ID (from API key)
   * @param cacheKey - Cache key to delete
   *
   * @example
   * ```typescript
   * await storage.deleteCache('user123', queryHash);
   * ```
   */
  async deleteCache(userId: string, cacheKey: string): Promise<void> {
    await this.kv.delete(this.cacheKey(userId, cacheKey));
  }
}
